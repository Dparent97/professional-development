# Key Learnings

*Lessons from building with AI - what actually worked*

## Multi-Agent Workflow

### What Works
- **3-4 agents is the sweet spot** - More creates coordination overhead, fewer loses parallelism benefit
- **Fresh context per phase** - Don't carry one giant conversation; start fresh with focused instructions
- **State files over memory** - WORKFLOW_STATE.json prevents "where am I?" confusion
- **Dependencies dictate merge order** - Agent 2 depends on Agent 1? Merge 1 first.
- **Sprint check-ins** - Periodic progress reports catch drift early

### What Doesn't Work
- **Symlinks in git repos** - Break portability, don't work in Claude Code web
- **Continuous sessions for complex work** - Context overflow, lost coherence
- **5+ agents** - Coordination overhead exceeds parallelism benefit
- **Vague agent prompts** - Specific files, specific outcomes, specific branch names

### Pattern: Agent Prompt Structure
```markdown
# Agent Role: [Specific Title]
Branch: [exact-branch-name]
Files to modify: [explicit list]
Definition of Done: [concrete checklist]
```

---

## Claude Skills

### Key Insight
Claude Skills are superior to API adapters because they can perform actual file system operations, git integration, and state management. API responses only provide text.

### Portability Rules
1. Never use symlinks in skill files
2. Test skills in Claude Code web, not just local
3. .skill files are just zips - can inspect contents
4. Copy files, don't link them

### When to Use Skills
- Repetitive workflows with consistent structure
- Operations that need file system access
- State management across conversations

### When NOT to Use Skills
- One-off tasks
- Simple questions
- Tasks that vary significantly each time

---

## Git Workflow

### Branch Naming
```
improve/1-short-description    # For improvements
feature/add-notifications      # For features
fix/login-timeout              # For bug fixes
claude/agent-name-uuid         # Auto-generated by agents (clean up after)
```

### Merge Strategy for Agent Branches
1. Run conflict analysis first (dry-run merge)
2. Merge clean branches in dependency order
3. For conflicts: resolve or skip, don't fight
4. Delete branches after merge
5. `git fetch --prune` to clean up

### Commit Discipline
- Commit after each logical chunk
- Don't batch unrelated changes
- Message format: `type: description`
- Never commit secrets or credentials

---

## Code Quality

### AI Code Review Checklist
When Claude generates code, check:
- [ ] Do I understand what this does?
- [ ] Are there hardcoded paths or credentials?
- [ ] Does error handling make sense?
- [ ] Is the naming clear?
- [ ] Would I be embarrassed if someone reviewed this?

### Testing Philosophy
- Tests for critical paths (auth, data, money)
- Don't chase 100% coverage
- Test behavior, not implementation
- If a test is flaky, fix or delete it

### Technical Debt Signals
- TODO comments piling up
- "Temporary" code lasting months
- Copy-pasted blocks
- Functions over 50 lines
- Files over 500 lines

---

## Token Efficiency

### What Burns Tokens
- Long unfocused conversations
- Pasting entire files when snippets would do
- Re-explaining context Claude already has
- Asking Claude to "remember" things (use Projects instead)

### What Saves Tokens
- Fresh conversations for new tasks
- Claude Projects with persistent knowledge
- Specific questions with clear scope
- State files that Claude can read vs. explain

### Rule of Thumb
If a conversation exceeds ~30 back-and-forths, consider:
- Starting fresh with a summary
- Breaking into separate tasks
- Creating a Project for persistent context

---

## Deployment

### Railway (what I know)
- Push to GitHub â†’ Railway auto-deploys
- Environment variables in Railway dashboard
- Logs available for debugging
- Free tier has limits

### Production Checklist
- [ ] Environment variables set (not in code)
- [ ] Error handling for user-facing paths
- [ ] Logging for debugging
- [ ] Basic monitoring (know when it's down)
- [ ] Backup plan for database

---

## Meta-Learning

### How I Learn Best
1. Build something that does X
2. When stuck, ask Claude specific questions
3. After it works, review WHY it works
4. Document the pattern
5. Apply to next project

### What Slows Me Down
- Trying to learn everything at once
- Collecting tools without using them
- Comparing myself to experienced developers
- Perfectionism before shipping

### What Accelerates Learning
- Real users (ship-MTA-draft crew)
- Deadlines (even self-imposed)
- Public repos (accountability)
- Teaching/documenting (forces clarity)

---

*Add new learnings as they emerge*
